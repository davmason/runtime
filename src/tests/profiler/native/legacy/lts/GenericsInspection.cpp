#include "../ProfilerCommon.h"

#ifdef WINDOWS
#include <process.h>
#include <winnt.h>
#endif

#include <thread>

#include <corhdr.h>
#include <windows.h>
#include <stdlib.h>
#include <chrono>
// Legacy support
#include "../LegacyCompat.h"
// Legacy support
 #ifdef __clang__
#pragma clang diagnostic ignored "-Wunused-function"
#pragma clang diagnostic ignored "-Wundefined-internal"
#endif // __clang__

using namespace std;


///////////////////////////////////////////////////////////////////////////////////
// Copied from Exceptions.cpp -- we shoudl probably make it better
///////////////////////////////////////////////////////////////////////////////////

//namespace /*imple*/
//{

//
// Helper class for simple allocation of buffer. Used mainly for functions
// that are expecting arrays.
//
template<class char_type , int bufferLength=255, class SizeType=ULONG32>
class BufferHolder
{
public:
    BufferHolder()
        : returned_(0)
    {
    }

    int size()  // returns size of buffer in items
    {
        return bufferLength;
    }

    char_type* buffer() // returns pointer to the buffer.
    {
        return static_buffer_;
    }

    SizeType* returned() // returns a reference to the returned size.
    {
        return &returned_;
    }

private:
    char_type static_buffer_[bufferLength];
    SizeType returned_;
};

/*
The profiler test is testing GetClassInfo2 & GetFunctionInfo2 calls.

================================================================================
ClassID's are delivered to the profiler from the following callbacks:
    HRESULT ClassLoadStarted(
                [in] ClassID classId);

    HRESULT ClassLoadFinished(
                [in] ClassID classId,
                [in] HRESULT hrStatus);

    HRESULT ClassUnloadStarted(
                [in] ClassID classId);

    HRESULT ClassUnloadFinished(
                [in] ClassID classId,
                [in] HRESULT hrStatus);

    HRESULT ObjectAllocated(
                [in] ObjectID objectId,
                [in] ClassID classId);

    HRESULT ObjectsAllocatedByClass(
                [in]                       ULONG   cClassCount,
                [in, size_is(cClassCount)] ClassID classIds[] ,
                [in, size_is(cClassCount)] ULONG   cObjects[] );

    HRESULT ObjectReferences(
                [in]                       ObjectID objectId,
                [in]                       ClassID  classId,
                [in]                       ULONG    cObjectRefs,
                [in, size_is(cObjectRefs)] ObjectID objectRefIds[] );

    HRESULT COMClassicVTableCreated(
               [in] ClassID wrappedClassId,
               [in] REFGUID implementedIID,
               [in] void    *pVTable,
               [in] ULONG   cSlots);

    HRESULT COMClassicVTableDestroyed(
               [in] ClassID wrappedClassId,
               [in] REFGUID implementedIID,
               [in] void    *pVTable);


It can also be retrieved from following ICorProf calls:
    HRESULT GetClassFromObject(
                [in]  ObjectID objectId,
                [out] ClassID *pClassId);

    HRESULT GetClassFromToken(
                [in]  ModuleID  moduleId,
                [in]  mdTypeDef typeDef,
                [out] ClassID   *pClassId);

    HRESULT IsArrayClass(
                [in]  ClassID        classId,
                [out] CorElementType *pBaseElemType,
                [out] ClassID        *pBaseClassId,
                [out] ULONG          *pcRank);

    HRESULT GetFunctionInfo(
                [in]  FunctionID functionId,
                [out] ClassID    *pClassId,
                [out] ModuleID   *pModuleId,
                [out] mdToken    *pToken);

    HRESULT GetFunctionInfo2(
                [in] FunctionID funcId,
                [in] COR_PRF_FRAME_INFO frameInfo,
                [out] ClassID *pClassId,
                [out] ModuleID *pModuleId,
                [out] mdToken *pToken,
                [in] ULONG32 cTypeArgs,
                [out] ULONG32 *pcTypeArgs,
                [out] ClassID typeArgs[]);

    HRESULT GetFunctionFromTokenAndTypeArgs(
                    [in] ModuleID moduleID,
                    [in] mdMethodDef funcDef,
                    [in] ClassID classId,
                    [in] ULONG32 cTypeArgs,
                    [in, size_is(cTypeArgs)] ClassID typeArgs[],
                    [out] FunctionID* pFunctionID);




Strategy:
---------
1) call GetClassInfo2() on all ClassID's generated by GetClassFromTokenAndTypeArgs() for
every loaded module.

2) Call GetClassInfo on every classID generated from all possible callbakcs that we
receive.

3) Round-trip the ClassID's through GetClassFromTokenAndTypeArgs x GetClassInfo2.


================================================================================
FunctionID's are delivered to the profiler from the following callbacks:

 FunctionIDMapper(FunctionID funcId,
                  BOOL *pbHookFunction);
typedef void FunctionEnter/Leave/Tailcall (+extended -2 versions)(
                FunctionID funcID);

typedef HRESULT __stdcall StackSnapshotCallback(
                FunctionID funcId,
                UINT_PTR ip,
                COR_PRF_FRAME_INFO frameInfo,
                ULONG32 contextSize,
                BYTE context[],
                void *clientData);

    HRESULT FunctionUnloadStarted(
                [in] FunctionID functionId);

    HRESULT JITCompilationStarted(
                [in] FunctionID functionId,
                [in] BOOL       fIsSafeToBlock);

    HRESULT JITCompilationFinished(
                [in] FunctionID functionId,
                [in] HRESULT    hrStatus,
                [in] BOOL       fIsSafeToBlock);

    HRESULT JITCachedFunctionSearchStarted(
                [in] FunctionID functionId,
                [out] BOOL      *pbUseCachedFunction);

    HRESULT JITFunctionPitched(
                [in] FunctionID functionId);
    HRESULT JITInlining(
                [in] FunctionID callerId,
                [in] FunctionID calleeId,
                [out] BOOL      *pfShouldInline);

    HRESULT UnmanagedToManagedTransition(
                [in] FunctionID                functionId,
                [in] COR_PRF_TRANSITION_REASON reason);

    HRESULT ManagedToUnmanagedTransition(
                [in] FunctionID                functionId,
                [in] COR_PRF_TRANSITION_REASON reason);

    HRESULT ExceptionSearchFunctionEnter(
                [in] FunctionID functionId);

    HRESULT ExceptionSearchFilterEnter(
                [in] FunctionID functionId);

    HRESULT ExceptionSearchCatcherFound(
                [in] FunctionID functionId);

    HRESULT ExceptionUnwindFunctionEnter(
                [in] FunctionID functionId);

    HRESULT ExceptionUnwindFinallyEnter(
                [in] FunctionID functionId);

    HRESULT ExceptionCatcherEnter(
                [in] FunctionID functionId,
                [in] ObjectID   objectId);

ICorProfilerInfo calls:
    HRESULT GetCodeInfo(
                [in]  FunctionID functionId,
                [out] LPCBYTE    *pStart,
                [out] ULONG      *pcSize);

    HRESULT GetFunctionFromIP(
                [in]  LPCBYTE    ip,
                [out] FunctionID *pFunctionId);

    HRESULT GetFunctionFromToken(
                [in]  ModuleID   moduleId,
                [in]  mdToken    token,
                [out] FunctionID *pFunctionId);

    HRESULT SetFunctionReJIT(
                [in] FunctionID functionId);

    HRESULT GetTokenAndMetaDataFromFunction(
                [in]  FunctionID functionId,
                [in]  REFIID     riid,
                [out] IUnknown   **ppImport,
                [out] mdToken    *pToken);

    HRESULT SetILInstrumentedCodeMap(
                [in]                         FunctionID functionId,
                [in]                         BOOL       fStartJit,
                [in]                         ULONG      cILMapEntries,
                [in, size_is(cILMapEntries)] COR_IL_MAP rgILMapEntries[] );

    HRESULT GetCodeInfo2(
                [in] FunctionID functionID,
                [in] ULONG32 cCodeInfos,
                [out] ULONG32 *pcCodeInfos,
                [out, size_is(cCodeInfos), length_is(*pcCodeInfos)]
                COR_PRF_CODE_INFO codeInfos[]);

    HRESULT GetFunctionFromTokenAndTypeArgs(
                    [in] ModuleID moduleID,
                    [in] mdMethodDef funcDef,
                    [in] ClassID classId,
                    [in] ULONG32 cTypeArgs,
                    [in, size_is(cTypeArgs)] ClassID typeArgs[],
                    [out] FunctionID* pFunctionID);

*/

extern IPrfCom * pPrfCom;

////////////////////////////////////////////////////////////////////////////////
// CONFIGURATION OPTIONS -- they will be read from environment string
////////////////////////////////////////////////////////////////////////////////

class ConfigurationOption
{
public:
    ConfigurationOption(const PLATFORM_WCHAR* envVarName,bool defaultValue)
        : name_( envVarName )
    {
        wstring envVar = ReadEnvironmentVariable(envVarName);
        if (envVar != L"")
            value_ = wcstol(envVar.c_str(), NULL, 10) != 0;
        else
            value_ = defaultValue;
        g_configs.push_back( this );
    }

    operator bool() const
    {
        return value_;
    }

    static void DumpConfig()
    {

        DISPLAY( L"CURENT CONFIGURATION\n");
        DISPLAY( L"====================\n");

        struct Callback {
            void operator()(const ConfigurationOption* option)
            {
                DISPLAY(L"set " << option->name_ << "=" << option->value_ << "\n");
            }
        } c;
        std::for_each( g_configs.begin(), g_configs.end(), c);
        DISPLAY(L"====================\n");
    }
private:
    bool value_;
    const PLATFORM_WCHAR* name_;

    static std::vector<ConfigurationOption*> g_configs;
};
std::vector<ConfigurationOption*> ConfigurationOption::g_configs;

ConfigurationOption g_autoGenerateClassIDs      (L"GI_AutoGenClassIDs",          false);
ConfigurationOption g_autoGenerateFunctionIDs   (L"GI_AutoGenFuncIDs",           false);

ConfigurationOption g_useReceivedClassIDs       (L"GI_UseReceivedClassIDs",      true);
ConfigurationOption g_useReceivedFunctionIDs    (L"GI_UseReceivedFuncIDs",       true);
ConfigurationOption g_useDoSnapCallstack        (L"GI_UseDoSNapCallstack",       true);;

ConfigurationOption g_testGetCodeInfo           (L"GI_TestCodeInfo",             true); // is dependend on testing functionID's

ConfigurationOption g_roundTrip                 (L"GI_RoundTrip",                true);

// Unit testing features....
ConfigurationOption g_doRangeTesting            (L"GI_RangeTesting",             true);

ConfigurationOption g_setUseProfileImages       (L"GI_UseProfileImages",         false);


typedef vector<ClassID> ClassIDsList;

ClassIDsList g_classIDs;

std::mutex g_lock;


template<typename Callback>
void GenerateClassIDForModule(ModuleID module, Callback validClassID)
{
    lock_guard<mutex> lock(g_lock);

    int index = 1;
    int _FAILURE_OLD_s = 0;
    while( true )
    {
        mdTypeDef token = TokenFromRid( mdtTypeDef, index);
        ClassID classID;
        HRESULT hr =
            pPrfCom->m_pInfo->GetClassFromTokenAndTypeArgs(module, token,
                                                           0, NULL, // no generic params
                                                           &classID);
        if( SUCCEEDED( hr ) )
        {
        haveClassID:
            _FAILURE_OLD_s = 0;
            // we have a new classID...
            g_classIDs.push_back( classID );
            validClassID( classID );
        }
        else
        {
            // this might be  a generic type ... Let's try with up to 10 args.
            if( !g_classIDs.empty() )
            {
                const int MAX_TEMPLATE_ARGS=10;

                ClassID list[MAX_TEMPLATE_ARGS];
                for(unsigned args = 1; args<= MAX_TEMPLATE_ARGS; ++args)
                {
                    if( args < g_classIDs.size() )
                        list[args-1] = g_classIDs[args-1];
                    else
                        list[args-1] = g_classIDs[0];
                    HRESULT hr =
                        pPrfCom->m_pInfo->GetClassFromTokenAndTypeArgs(module, token,
                                                                       args, list,
                                                                       &classID);
                    if (SUCCEEDED(hr))
                        goto haveClassID;
                    else
                        DISPLAY(L"GetClassFromTokenAndTypeArgs(0x" << HEX(token) << ",args=" << args << ") returned hr=" << HEX(hr) << "\n");
                }
            }
            if( ++_FAILURE_OLD_s > 10 )
                break;
        }
        ++index;
    }
}

template<typename Callback>
void GenerateFunctionIDForModule(ModuleID module, Callback validFunctionID)
{
    lock_guard<mutex> lock(g_lock);

    int index = 1;
    int _FAILURE_OLD_s = 0;
    while( true )
    {
        mdToken token = TokenFromRid( mdtMethodDef, index);
        FunctionID functionID;
        HRESULT hr =
            pPrfCom->m_pInfo->GetFunctionFromToken(module, token, &functionID); // @TODO investigate why it is failing
        DISPLAY(L"GetFunctionFromToken(moduleId=0x" << HEX(module) << L", token=0x" << HEX(token) << L")=hr(0x" << HEX(hr) << L")\n");

        if( SUCCEEDED( hr ) )
        {
            _FAILURE_OLD_s = 0;
            // we have a new functionID...
            validFunctionID( functionID );
        }
        else
        {
            if( ++_FAILURE_OLD_s>100 )
                break;
        }
        ++index;
    }
}

inline void doRoundTrippingWithClassIDs(ClassID classID, bool notFullyLoadedClass)
{
    ModuleID    moduleID;
    mdTypeDef   typeDefToken;
    ClassID     parent;

    const int   MAX_TEMPLATE_ARGS=100;
    ClassID     typeArgs[MAX_TEMPLATE_ARGS];
    unsigned    typeArgsCount;
    HRESULT hr =
        pPrfCom->m_pInfo->GetClassIDInfo2( classID, &moduleID, &typeDefToken, &parent,
                                           MAX_TEMPLATE_ARGS, &typeArgsCount, typeArgs );

    if (hr != S_OK)
        FAILURE(L"GetClassIDInfo2 (nflc=" << notFullyLoadedClass << ") for valid ClassID returned hr=0x" << HEX(hr) << L"\n");

    ClassID     classID2;
    hr = pPrfCom->m_pInfo->GetClassFromTokenAndTypeArgs(moduleID, typeDefToken, typeArgsCount, typeArgs,
                                                        &classID2);

    if( //notFullyLoadedClass &&
       hr == CORPROF_E_DATAINCOMPLETE ||
       hr == COR_E_TYPELOAD )
        return;

    if (hr != S_OK)
        FAILURE(L"GetClassFromTokenAndTypeArgs(nflc=" << notFullyLoadedClass << ") for valid ClassID returned hr=0x" << HEX(hr) << "\n");

    if (classID2 != classID)
        FAILURE(L"classID2(" << HEX(classID) << ") != classID(" << HEX(classID2) << L")\n");
}

unsigned testedClassIDs=0;

inline void testClassID(ClassID classID, bool notFullyLoadedClass = false)
{
    if( classID==0 )
        FAILURE( L"classID==0");

    if( !g_useReceivedClassIDs )
        return;

    lock_guard<mutex> lock(g_lock);

    ModuleID    moduleID;
    mdTypeDef   typeDefToken;
    ClassID     parent;

    // @tODO do we get 1000.
    const int   MAX_TEMPLATE_ARGS=100;
    ClassID     typeArgs[MAX_TEMPLATE_ARGS];
    unsigned    typeArgsCount;
    HRESULT hr =
        pPrfCom->m_pInfo->GetClassIDInfo2( classID, &moduleID, &typeDefToken, &parent,
                                           MAX_TEMPLATE_ARGS, &typeArgsCount, typeArgs );

    // test if this is array class.
    CorElementType      arrayEt;
    ClassID             arrayBaseClassId;
    ULONG               arrayPcRank;
    HRESULT hr2 = pPrfCom->m_pInfo->IsArrayClass( classID, &arrayEt, &arrayBaseClassId, &arrayPcRank);

    switch( hr )
    {
    case CORPROF_E_CLASSID_IS_ARRAY:
        {
            if( hr2!=S_OK )
                FAILURE( L"IsArrayClass returned false" );
            testClassID( arrayBaseClassId, notFullyLoadedClass );
        }
        break;

    case CORPROF_E_CLASSID_IS_COMPOSITE:

#if BUG515110_FIXED
        if( hr2 != S_FALSE )
#else
        if( hr2 != S_FALSE && hr2 != S_OK )
#endif // BUG515110_FIXED
        {
            FAILURE(L" IsArrayClass returned hr=0x" << HEX(hr2) << L"\n");
        }

        return; // we cannot do anything with this classID.

    case S_OK:
        {
        if (hr2 != S_FALSE)
            FAILURE(L" IsArrayClass returned hr=0x" << HEX(hr2) << L"\n");

            // we should better do some checking of returned values...
            if( parent!= 0 )
                testClassID( parent );

            if( typeArgsCount > MAX_TEMPLATE_ARGS )
                FAILURE( L"Wrong typeArgsCount");
            for( unsigned i=0; i < typeArgsCount; ++i )
                testClassID( typeArgs[i] );

            ++testedClassIDs;

            // Roundtripping using GetClassFromTokenAndTypeArgs is unsafe.
            // GetClassFromTokenAndTypeArgs is an unsafe function to call.  Ever.
            //if( g_roundTrip )
            //    doRoundTrippingWithClassIDs(classID, notFullyLoadedClass);
        }
        break;
    default:
        FAILURE(L"GetClassIDInfo2 for valid ClassID returned hr=0x" << HEX(hr) << L"\n");
        break;
    }

}

inline void doRoundTrippingWithFunctionIDs(FunctionID functionID, COR_PRF_FRAME_INFO frameInfo, bool DisableSpecialCase )
{

    const int   MAX_TEMPLATE_ARGS=100;
    ClassID     typeArgs[MAX_TEMPLATE_ARGS];
    unsigned    typeArgsCount;

    ClassID classID;
    ModuleID moduleID;
    mdToken token;
    HRESULT hr =
        pPrfCom->m_pInfo->GetFunctionInfo2(functionID, frameInfo, &classID,
                                           &moduleID, &token,
                                           MAX_TEMPLATE_ARGS,
                                           &typeArgsCount, typeArgs);

    if (hr != S_OK)
        FAILURE(L"GetFunctionInfo2 for valid functionID returned hr=0x" << HEX(hr) << L"\n");

    if( classID==0 )
    {
        if( frameInfo==0 )
            return;                                         //  this can happen when
                                                            //  we don't have frameInfo
        FAILURE(L"GetFunctionInfo2 returned 0 classID for functionID(0x" << HEX(functionID) << ")\n");
    }

    if (moduleID == 0)
        FAILURE(L"GetFunctionInfo2 returned 0 moduleID for functionID(0x" << HEX(functionID) << ")\n");

    if(!DisableSpecialCase)
    {
      FunctionID functionID2;
      hr = pPrfCom->m_pInfo->GetFunctionFromTokenAndTypeArgs(moduleID, token, classID, typeArgsCount, typeArgs,
                                                           &functionID2);
      if (hr != S_OK)
          FAILURE(L"GetFunctionFromTokenAndTypeArgs for valid functionID returned hr=0x" << HEX(hr) << "\n");
      if (functionID != functionID2)
          FAILURE(L"functionID(0x" << HEX(functionID) << ") != functionID2(0x" << HEX(functionID2) << ")\n");
    }
}

void doTestCodeInfo(FunctionID functionID, bool mightNotBeCompiled, UINT_PTR ip)
{
    const int           MAX_CODE_INFOS = 100;
    COR_PRF_CODE_INFO  codeInfo[MAX_CODE_INFOS];
    unsigned            codeInfoCount;


    HRESULT hr =
        pPrfCom->m_pInfo->GetCodeInfo2(functionID,
                                       MAX_CODE_INFOS,
                                       &codeInfoCount,
                                       codeInfo);
    if( mightNotBeCompiled && hr==CORPROF_E_FUNCTION_NOT_COMPILED )
        return;

    if( hr!=S_OK )
        FAILURE(L"GetCodeInfo2(functionID=0x" << HEX(functionID) << ") returned hr=0x" << HEX(hr) << "\n");

    if (codeInfoCount < 1 || codeInfoCount > 2)
        FAILURE(L"GetCodeInfo2(functionID=0x" << HEX(functionID) << ") returned codeInfoCount=" << codeInfoCount << "\n");
#if 0 // @TODO set a flag
    if( codeInfoCount>1 )
        _DISPLAY_OLD_(( L"GetCodeInfo2 returned %d regions!\n", codeInfoCount ));
#endif

    if( ip!=0 )
    {
        // verify that ip is in some code block
        bool isInCodeBlock=false;
        for(unsigned i=0; i < codeInfoCount; ++i)
        {
            if( codeInfo[i].startAddress<=ip &&
                codeInfo[i].startAddress+codeInfo[i].size > ip )
            {
                isInCodeBlock = true;
                break;
            }
        }
        if( !isInCodeBlock )
            FAILURE(L"GetCodeInfo2 returned block range that doesn't cover current IP" );
    }

    LPCBYTE start;
    ULONG length;
    hr = pPrfCom->m_pInfo->GetCodeInfo(functionID, &start, &length);

    if (hr != S_OK)
        FAILURE(L"GetCodeInfo(functionID=0x" << HEX(functionID) << ") returned hr=0x" << HEX(hr) << "\n");

    // if GetCodeInfo succeeded, it means that there is only one region. let's compare the
    // output of the two functions.
    if( codeInfoCount==1 )
    {
        if (reinterpret_cast<void*>(codeInfo[0].startAddress)
            != reinterpret_cast<const void*>(start) ||
            codeInfo[0].size != length)
            FAILURE(L"GetCodeInfo(0x" << HEX(codeInfo[0].startAddress) << ":0x" << HEX(codeInfo[0].size) << ") && " <<
                "GetCodeInfo2(0x" << HEX(start) << ":0x" << HEX(length) << ") dont match\n");
    }
    else
    {
        if( reinterpret_cast<void*>(codeInfo[0].startAddress)
            != reinterpret_cast<const void*>(start) ||
            codeInfo[0].size != length )
            FAILURE( L"GetCodeInfo && GetCodeInfo returned inconsistent results\n");

        //_DISPLAY_OLD_(( L"GetCodeInfo(%x,%x), GetCodeInfo2(%x,%x,%x,%x)\n",
        // start,length, codeInfo[0].startAddress, codeInfo[0].size,
        //codeInfo[1].startAddress, codeInfo[1].size ));
    }

}

unsigned testedFunctionIDs = 0;
enum might_not_be_compiled_t {
    is_compiled,
    might_not_be_compiled,
    might_not_work_at_all
};


inline void testFunctionID(FunctionID functionID, COR_PRF_FRAME_INFO frameInfo = 0,
                           might_not_be_compiled_t mightNotBeCompiled = is_compiled,
                           UINT_PTR ip = 0, bool DisableSpecialCase = false)
{
    if( !g_useReceivedFunctionIDs )
        return;

    lock_guard<mutex> lock(g_lock);

    const int   MAX_TEMPLATE_ARGS=100;
    ClassID     typeArgs[MAX_TEMPLATE_ARGS];
    unsigned    typeArgsCount;

    ClassID classID;
    ModuleID moduleID;
    mdToken token;
    HRESULT hr =
        pPrfCom->m_pInfo->GetFunctionInfo2(functionID, frameInfo, &classID,
                                           &moduleID, &token,
                                           MAX_TEMPLATE_ARGS,
                                           &typeArgsCount, typeArgs);
    if( hr != S_OK )
        return; // @TODO BUG BUG
    //        _FAILURE_OLD_(( L"GetFunctionInfo2 for valid functionID returned hr=0x%x", hr ));

    if( classID!= 0 )
        testClassID( classID );
    else
    {
        if( frameInfo!= 0 )
            FAILURE( L"GetFunctionInfo2 returned 0 classID even when frameInfo was passed-in");
    }

    for( unsigned i=0; i < typeArgsCount; ++i )
        testClassID( typeArgs[i] );

    ++testedFunctionIDs;

    if( g_roundTrip &&
        (mightNotBeCompiled==is_compiled) // @BUG 530636
        )
    doRoundTrippingWithFunctionIDs(functionID, frameInfo,DisableSpecialCase );

    if( g_testGetCodeInfo )
    {
        // some functionID's simply don't work --- e.g. functionID's for inlined functions.
        if( mightNotBeCompiled != might_not_work_at_all )
        {
            doTestCodeInfo( functionID, mightNotBeCompiled==might_not_be_compiled, ip );
        }
    }
}

class ThreadStore
{
public:
    ThreadStore()
    //      : threadIdStore_(1024) /* we don't expect to have more than 1024 threads*/
    {}

    void add(ThreadID threadId)
    {
        lock_guard<mutex> lock(threadAccessMutex_);
        threadIdStore_t::iterator i = std::find( threadIdStore_.begin(), threadIdStore_.end(),
                                                 threadId );
        if( i != threadIdStore_.end() )
            FAILURE( L"ThreadID(0x" << HEX(threadId) << ") is already in ThreadStore\n" );
        threadIdStore_.push_back( threadId );
    }

    void remove(ThreadID threadId)
    {
        lock_guard<mutex> lock(threadAccessMutex_);
        threadIdStore_t::iterator i = std::find( threadIdStore_.begin(), threadIdStore_.end(),
                                                 threadId );
        if( i == threadIdStore_.end() )
            FAILURE( L"ThreadID(0x" << HEX(threadId) << ") is missing in the ThreadStore\n");
        threadIdStore_.erase( i );
    }

    template<typename Callback>
    void iterateOverThreads(Callback callback)
    {
        lock_guard<mutex> lock(threadAccessMutex_);
        std::for_each( threadIdStore_.begin(), threadIdStore_.end(), callback );
    }

private:
    std::mutex threadAccessMutex_;
    typedef std::vector<ThreadID> threadIdStore_t;
    threadIdStore_t threadIdStore_;
} g_availableThreads;


unsigned executedDoStackSnapshot=0;

    struct DSS_Data {
        FunctionID               funcId;
        UINT_PTR                 ip;
        COR_PRF_FRAME_INFO       frameInfo;
    };

    HRESULT __stdcall CallbackFunction(FunctionID funcId, UINT_PTR ip, COR_PRF_FRAME_INFO frameInfo,
                                              ULONG32 /*contextSize*/, BYTE /*context[]*/, void *clientData);

class StackSnapshot {
public:
//ARM does not support ICorProfilerInfo2::DoStackSnapshot Method. So we will use RtlVirtualUnwind to do the stack walk.
#if defined(_ARM_) && defined(WIN32)
    void doStackSnapshot(ThreadID threadID)
    {
        DWORD osThreadId;
        count_ = 0;
        pPrfCom->m_pInfo->GetThreadInfo(threadID, &osThreadId);
        HANDLE hThreadTarget = OpenThread(THREAD_ALL_ACCESS, FALSE, (DWORD)osThreadId);
        DWORD dwRet = SuspendThread(hThreadTarget);
        _ASSERTE(dwRet != (DWORD) -1);

        CONTEXT ctx;
        ZeroMemory(&ctx, sizeof(ctx));
        ctx.ContextFlags = CONTEXT_FULL | CONTEXT_EXCEPTION_REQUEST;

        if (!GetThreadContext(hThreadTarget, &ctx))
            _ASSERTE(!"GetThreadContext failed");

        _ASSERTE(ctx.ContextFlags & CONTEXT_EXCEPTION_REPORTING);

        WalkStack(&ctx);

        dwRet = ResumeThread(hThreadTarget);
        _ASSERTE(dwRet != (DWORD) -1);


        for(int i=0; i<count_; ++i)
            testFunctionID( data_[i].funcId, data_[i].frameInfo, is_compiled, data_[i].ip );

        ++executedDoStackSnapshot;

    }

    void WalkStack(CONTEXT * pCtx)
    {
        BOOL fContinue;
        do
        {
            fContinue = WalkFrame(pCtx);
        }
        while (fContinue);
    }

    BOOL WalkFrame(CONTEXT* pCtx)
    {
        if (pCtx->Pc == 0)
        {
            // All done
            return FALSE;
        }

        DWORD dwImageBase;
        PRUNTIME_FUNCTION pRuntimeFunction =  RtlLookupFunctionEntry(
            pCtx->Pc,
            &dwImageBase,
            NULL);  // HistoryTable

        if (pRuntimeFunction == NULL)
        {
            // Nested functions that do not use any stack space or nonvolatile
            // registers are not required to have unwind info (ex.
            // USER32!ZwUserCreateWindowEx).
            pCtx->Pc = *(DWORD*)(pCtx->Sp);
            pCtx->Sp += sizeof(DWORD);
            return TRUE;
        }

        // For debugging purposes, reserve a clean copy of what we're passing in to
        // RtlVirtualUnwind that we know has not been modified by RtlVirtualUnwind
        CONTEXT ctxOld;
        memcpy(&ctxOld, pCtx, sizeof(ctxOld));

        LPVOID pHandlerData = NULL;
        DWORD dwEstablisherFrame;

        PEXCEPTION_ROUTINE pExceptionRoutine = NULL;

        FunctionID funcID = NULL;
        HRESULT hr = pPrfCom->m_pInfo->GetFunctionFromIP((LPCBYTE)pCtx->Pc, &funcID);

        if( this->count_ < this->MAX_CAPTURED && funcID)
        {
            DSS_Data& d = this->data_[this->count_++];
            d.funcId   = funcID;
            d.ip       = (UINT_PTR)pCtx->Pc;
            d.frameInfo= 0;
        }

        __try
        {
            pExceptionRoutine = RtlVirtualUnwind(
                NULL,               // HandlerType,
                dwImageBase,
                pCtx->Pc,
                pRuntimeFunction,
                pCtx,
                &pHandlerData,
                &dwEstablisherFrame,
                NULL);              // ContextPointers
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            // RtlVirtualUnwind is known to AV sometimes when the target thread is
            // unwalkable. The example we regularly hit is when the target is suspended
            // toward the end of RtlRestoreContext, after rbp has been modified.
            return FALSE;
        }

        return TRUE;
    }
#else
    void doStackSnapshot(ThreadID threadID)
    {
        count_ = 0;
        HRESULT hr =
            pPrfCom->m_pInfo->DoStackSnapshot(threadID,
                                              (StackSnapshotCallback *)&CallbackFunction,
                                              COR_PRF_SNAPSHOT_DEFAULT,
                                              this,
                                              NULL, 0);
        if (hr != S_OK
            && hr != E_FAIL && hr != CORPROF_E_STACKSNAPSHOT_UNMANAGED_CTX
            && hr != CORPROF_E_STACKSNAPSHOT_UNSAFE
            && hr != CORPROF_E_STACKSNAPSHOT_ABORTED // can happen....
            )
            FAILURE(L"DoStackSnapshot returned hr=0x" << HEX(hr) << "\n");

        // now test results from the stack
        for(int i=0; i<count_; ++i)
            testFunctionID( data_[i].funcId, data_[i].frameInfo, is_compiled, data_[i].ip );

        ++executedDoStackSnapshot;
    }
#endif

    enum {MAX_CAPTURED=4097};

    int count_;
    DSS_Data data_[MAX_CAPTURED];

};

    HRESULT __stdcall CallbackFunction(FunctionID funcId, UINT_PTR ip, COR_PRF_FRAME_INFO frameInfo,
                                              ULONG32 /*contextSize*/, BYTE /*context[]*/, void *clientData)
    {
        StackSnapshot* This = static_cast<StackSnapshot*>(clientData);

        // we cannot do too much in the callback.
        if( This->count_ < This->MAX_CAPTURED )
        {
            if( funcId==0 )
                goto Exit;

            if( ip==0 )
                FAILURE( L"DoStackSnapshot returned 0 IP");

            DSS_Data& d = This->data_[This->count_++];
            d.funcId   = funcId;
            d.ip       = ip;
            d.frameInfo= frameInfo;
        }
    Exit:
        return S_OK;
    }


HRESULT GI_ModuleLoadStarted(IPrfCom * /*pPrfCom*/, ModuleID /*moduleId*/)
{
    HRESULT hr = S_OK;

    return hr;
}

HRESULT GI_ModuleLoadFinished(IPrfCom * pPrfCom, ModuleID moduleId, HRESULT hrStatus)
{
    DISPLAY( L"Load Finished\n");
    if( SUCCEEDED( hrStatus ) )
    {
        if( g_autoGenerateFunctionIDs )
        {
            struct Callback
            {
                void operator()(FunctionID functionID)
                {
                    //DISPLAY( L"Got FunctionID... \n");
                    testFunctionID( functionID, 0, might_not_be_compiled );
                }
            } c;
            GenerateFunctionIDForModule(moduleId, c );
        }
    }
    return S_OK;
}

HRESULT GI_ClassLoadStarted(IPrfCom * /*_pPrfCom*/, ClassID classId)
{
    testClassID( classId, true );
    return S_OK;
}


HRESULT GI_ClassLoadFinished(IPrfCom * /*pPrfCom*/, ClassID classId, HRESULT /*hrStatus*/)
{
    testClassID( classId );
    return S_OK;
}

HRESULT GI_ClassUnloadStarted(IPrfCom* /*pPrfCom*/, ClassID classId)
{
    testClassID( classId );
    return S_OK;
}

HRESULT GI_ClassUnloadFinished(IPrfCom* /*pPrfCom*/, ClassID classId, HRESULT /*hrStatus*/)
{
    testClassID( classId );
    return S_OK;
}

HRESULT GI_ObjectAllocated(IPrfCom* /*pPrfCom*/, ObjectID /*objectId*/, ClassID classId)
{
    testClassID( classId );
    return S_OK;
}

HRESULT GI_ObjectsAllocatedByClass(IPrfCom* /*pPrfCom*/, ULONG   cClassCount, ClassID classIds[],
                                   ULONG   /*cObjects[]*/ )
{
    for(unsigned i=0; i< cClassCount; ++i)
        testClassID( classIds[i] );
    return S_OK;
}

HRESULT GI_ObjectReferences(IPrfCom* /*pPrfCom*/, ObjectID /*objectId*/, ClassID  classId,
                            ULONG    /*cObjectRefs*/, ObjectID /*objectRefIds[]*/ )
{
    if (classId != 0)
        testClassID( classId );
    return S_OK;
}



HRESULT GI_COMClassicVTableCreated(IPrfCom* /*pPrfCom*/, ClassID wrappedClassId,
                                   REFGUID /*implementedIID*/, void * /*pVTable*/, ULONG   /*cSlots*/)
{
    testClassID( wrappedClassId );
    return S_OK;
}


HRESULT GI_COMClassicVTableDestroyed(IPrfCom* /*pPrfCom*/, ClassID wrappedClassId,
                                     REFGUID /*implementedIID*/, void * /*pVTable*/)
{
    testClassID( wrappedClassId );
    return S_OK;
}

HRESULT GI_JITCachedFunctionSearchStarted(IPrfCom* /*pPrfCom*/, FunctionID functionId,
                                          BOOL * /*pbUseCachedFunction*/)
{
    testFunctionID( functionId );
    return S_OK;
}

HRESULT GI_FunctionUnloadStarted(IPrfCom* /*pPrfCom*/, FunctionID functionId)
{
    testFunctionID( functionId );
    return S_OK;
}


HRESULT GI_JITCompilationStarted(IPrfCom* /*pPrfCom*/, FunctionID functionId, BOOL /*fIsSafeToBlock*/)
{
    testFunctionID( functionId, 0, might_not_be_compiled );
    return S_OK;
}


HRESULT GI_JITCompilationFinished(IPrfCom* /*pPrfCom*/, FunctionID functionId,HRESULT /*hrStatus*/,BOOL /*fIsSafeToBlock*/)
{
    testFunctionID( functionId );
    return S_OK;
}


HRESULT GI_JITFunctionPitched(IPrfCom* /*pPrfCom*/, FunctionID functionId)
{
    testFunctionID( functionId );
    return S_OK;
}


HRESULT GI_JITInlining(IPrfCom* /*pPrfCom*/, FunctionID callerId, FunctionID calleeId, BOOL * /*pfShouldInline*/)
{
    testFunctionID( callerId, 0, might_not_work_at_all ); // BUG 530636
    testFunctionID( calleeId, 0, might_not_work_at_all ); // BUG 530636
    return S_OK;
}


HRESULT GI_UnmanagedToManagedTransition(IPrfCom* /*pPrfCom*/, FunctionID functionId,COR_PRF_TRANSITION_REASON reason)
{
    if( reason != COR_PRF_TRANSITION_CALL &&
        reason != COR_PRF_TRANSITION_RETURN )
        FAILURE( L"Invalid reason=\n");

    if( functionId==0 && reason == COR_PRF_TRANSITION_RETURN )
        goto Exit;// allowed combination according to doc.

    testFunctionID( functionId, NULL, might_not_be_compiled );
 Exit:
    return S_OK;
}


HRESULT GI_ManagedToUnmanagedTransition(IPrfCom* /*pPrfCom*/, FunctionID functionId,COR_PRF_TRANSITION_REASON reason)
{
    if( reason != COR_PRF_TRANSITION_CALL &&
        reason != COR_PRF_TRANSITION_RETURN )
        FAILURE( L"Invalid reason=%d\n");

    if( functionId==0 && reason == COR_PRF_TRANSITION_CALL )
        goto Exit;// allowed combination according to doc.

    testFunctionID( functionId, NULL, might_not_be_compiled );
 Exit:
    return S_OK;
}


HRESULT GI_ExceptionSearchFunctionEnter(IPrfCom* /*pPrfCom*/, FunctionID functionId)
{
    testFunctionID( functionId );
    return S_OK;
}


HRESULT GI_ExceptionSearchFilterEnter(IPrfCom* /*pPrfCom*/, FunctionID functionId)
{
    testFunctionID( functionId );
    return S_OK;
}


HRESULT GI_ExceptionSearchCatcherFound(IPrfCom* /*pPrfCom*/, FunctionID functionId)
{
    testFunctionID( functionId );
    return S_OK;
}


HRESULT GI_ExceptionUnwindFunctionEnter(IPrfCom* /*pPrfCom*/, FunctionID functionId)
{
    testFunctionID( functionId, 0, is_compiled, 0, true );
    return S_OK;
}


HRESULT GI_ExceptionUnwindFinallyEnter(IPrfCom* /*pPrfCom*/, FunctionID functionId)
{
    testFunctionID( functionId );
    return S_OK;
}


HRESULT GI_ExceptionCatcherEnter(IPrfCom* /*pPrfCom*/, FunctionID functionId, ObjectID   /*objectId*/)
{
    testFunctionID( functionId );
    return S_OK;
}


HRESULT GI_FunctionEnter3WithInfo(IPrfCom* /*pPrfCom*/, FunctionIDOrClientID functionIdOrClientID, COR_PRF_ELT_INFO /*eltInfo*/)
{
    testFunctionID( functionIdOrClientID.functionID, NULL);
    return S_OK;
}


HRESULT GI_FunctionLeave3WithInfo(IPrfCom* /*pPrfCom*/, FunctionIDOrClientID functionIdOrClientID, COR_PRF_ELT_INFO /*eltInfo */)
{
    testFunctionID( functionIdOrClientID.functionID, NULL);
    return S_OK;
}


HRESULT GI_FunctionTailCall3WithInfo(IPrfCom* /*pPrfCom*/, FunctionIDOrClientID functionIdOrClientID, COR_PRF_ELT_INFO /*eltInfo*/ )
{
    testFunctionID( functionIdOrClientID.functionID, NULL);
    return S_OK;
}



HRESULT GI_ThreadCreated(IPrfCom* /*pPrfCom*/, ThreadID threadId)
{
    //_DISPLAY_OLD_(( L"ThreadCreated(ThreadId=0x%x)", threadId ));
    g_availableThreads.add( threadId );
    return S_OK;
}


HRESULT GI_ThreadDestroyed(IPrfCom* /*pPrfCom*/, ThreadID threadId)
{
    //_DISPLAY_OLD_(( L"ThreadDestroyed(ThreadId=0x%x)", threadId ));
    g_availableThreads.remove( threadId );
    return S_OK;
}

class SnapCallstackWorkerThread
{
public:
    SnapCallstackWorkerThread()
        : thread_launch_cnt_(0)
    {}

    void start()
    {
        if( thread_launch_cnt_ !=0 )
            FAILURE( L"start called twice" );

        terminate_ = false;
//        thread_ = reinterpret_cast<HANDLE>( _beginthread( threadStartFunc, 0, this) );
        thread_ = std::thread(threadStartFunc, this);
        ++thread_launch_cnt_;
    }

    void terminate()
    {
        terminate_ = true;
        thread_.join();
    }

private:
    std::thread thread_;
    int thread_launch_cnt_ = 0;
    volatile bool terminate_;

    static void __cdecl threadStartFunc(void* arglist)
    {
        SnapCallstackWorkerThread* This = static_cast<SnapCallstackWorkerThread*>(arglist);

        // Perform necessary initialization on current thread in advance
        // to avoid deadlocks
        HRESULT hr = pPrfCom->m_pInfo4->InitializeCurrentThread();
        if (FAILED(hr))
            FAILURE(L"ICorProfilerInfo4::InitializeCurrentThread returned hr=0x" << HEX(hr) << "\n");

        while( !This->terminate_ )
        {
            std::this_thread::sleep_for(std::chrono::milliseconds(500));
            struct Callback
            {
                void operator()(ThreadID threadId)
                {
                    //_DISPLAY_OLD_(( L"DoSnapCallstack(ThreadId=0x%x)\n", threadId ));
                    StackSnapshot ss;
                    ss.doStackSnapshot( threadId );
                }
            } c;
            g_availableThreads.iterateOverThreads( c );
        }
    }

} g_snapCallstackWorkerThread;




HRESULT GI_Verify(IPrfCom * pPrfCom)
{
    if( g_useDoSnapCallstack )
        g_snapCallstackWorkerThread.terminate();

    DISPLAY(L"TestedClassID's          = " << testedClassIDs << L"\n");
    DISPLAY( L"TestedFunctionID's       = " << testedFunctionIDs << L"\n");
    DISPLAY( L"DoStackSnapshot's        = " << executedDoStackSnapshot << L"\n");
    return S_OK;
}

void GenericsInspection_Initialize (IPrfCom * _pPrfCom, PMODULEMETHODTABLE pModuleMethodTable)
{
    // save globally so that we don't have to pass it everywhere around.
    pPrfCom = _pPrfCom;

    DISPLAY( L"Initialize GenericsInspection extension\n");

    // dump all configurable values to the stdout...
    ConfigurationOption::DumpConfig();

    if( g_setUseProfileImages )
        pModuleMethodTable->FLAGS |= COR_PRF_USE_PROFILE_IMAGES;

    if( g_autoGenerateClassIDs || g_autoGenerateFunctionIDs )
        pModuleMethodTable->FLAGS |= COR_PRF_MONITOR_MODULE_LOADS;

    if( g_useReceivedClassIDs )
        pModuleMethodTable->FLAGS |=
            COR_PRF_MONITOR_CLASS_LOADS |                 // for Class{Load,Unload}{Started,Finished} callbacks
            COR_PRF_MONITOR_OBJECT_ALLOCATED |            // ObjectAllocated,
            COR_PRF_MONITOR_GC |                          // ObjectsAllocatedByClass,
            COR_PRF_MONITOR_CCW |                         // COMClassicVTable{Created,Destroyed}
            COR_PRF_MONITOR_EXCEPTIONS |                  // this is so we get exceptiosn callback and can get ClassID from objectID's.
            COR_PRF_MONITOR_CACHE_SEARCHES;               // we need to force calling JIT cases.


    if( g_useReceivedFunctionIDs )
        pModuleMethodTable->FLAGS |=
            COR_PRF_MONITOR_FUNCTION_UNLOADS |              // FunctionUnload{Started,Finished}
            COR_PRF_MONITOR_JIT_COMPILATION |               // JITCompilation{Started,Finished}, JITFunctionPitched, JITInlining
            COR_PRF_MONITOR_CACHE_SEARCHES |                // JITCachedFunctionSearchStarted
            COR_PRF_MONITOR_CODE_TRANSITIONS |              // UnmanagedToManagedTransition, ManagedToUnmanagedTransition
            COR_PRF_MONITOR_EXCEPTIONS |                    // ExceptionSearchFunctionEnter, ExceptionSearchFilterEnter
                                                            // ExceptionSearchCatcherFound, ExceptionUnwindFunctionEnter,
                                                            // ExceptionUnwindFinallyEnter, ExceptionCatcherEnter
            COR_PRF_MONITOR_ENTERLEAVE;                     // FunctionEnter/Leave.

    if( g_useDoSnapCallstack )
    {
        pModuleMethodTable->FLAGS |=
            COR_PRF_ENABLE_STACK_SNAPSHOT |                 // StackSnapshotCallback
            COR_PRF_MONITOR_THREADS;                        // ThreadCreate/Destroy callbacks.

        g_snapCallstackWorkerThread.start();
    }


    pModuleMethodTable->VERIFY                          = (FC_VERIFY)&GI_Verify;
    pModuleMethodTable->MODULELOADSTARTED               = (FC_MODULELOADSTARTED)&GI_ModuleLoadStarted;
    pModuleMethodTable->MODULELOADFINISHED              = (FC_MODULELOADFINISHED)&GI_ModuleLoadFinished;

    pModuleMethodTable->CLASSLOADSTARTED                = (FC_CLASSLOADSTARTED)&GI_ClassLoadStarted;
    pModuleMethodTable->CLASSLOADFINISHED               = (FC_CLASSLOADFINISHED)&GI_ClassLoadFinished;
    pModuleMethodTable->CLASSUNLOADSTARTED              = (FC_CLASSUNLOADSTARTED)&GI_ClassUnloadStarted;
    pModuleMethodTable->CLASSUNLOADFINISHED             = (FC_CLASSUNLOADFINISHED)&GI_ClassUnloadFinished;

    pModuleMethodTable->OBJECTSALLOCATEDBYCLASS         = (FC_OBJECTSALLOCATEDBYCLASS)&GI_ObjectsAllocatedByClass;
    pModuleMethodTable->OBJECTREFERENCES                = (FC_OBJECTREFERENCES)&GI_ObjectReferences;
    pModuleMethodTable->COMCLASSICVTABLECREATED         = (FC_COMCLASSICVTABLECREATED)&GI_COMClassicVTableCreated;
    pModuleMethodTable->COMCLASSICVTABLEDESTROYED       = (FC_COMCLASSICVTABLEDESTROYED)&GI_COMClassicVTableDestroyed;
    pModuleMethodTable->JITCACHEDFUNCTIONSEARCHSTARTED  = (FC_JITCACHEDFUNCTIONSEARCHSTARTED)&GI_JITCachedFunctionSearchStarted;

    pModuleMethodTable->FUNCTIONUNLOADSTARTED           = (FC_FUNCTIONUNLOADSTARTED)&GI_FunctionUnloadStarted;
    pModuleMethodTable->JITCOMPILATIONSTARTED           = (FC_JITCOMPILATIONSTARTED)&GI_JITCompilationStarted;
    pModuleMethodTable->JITCOMPILATIONFINISHED          = (FC_JITCOMPILATIONFINISHED)&GI_JITCompilationFinished;
    pModuleMethodTable->JITFUNCTIONPITCHED              = (FC_JITFUNCTIONPITCHED)&GI_JITFunctionPitched;
    pModuleMethodTable->JITINLINING                     = (FC_JITINLINING)&GI_JITInlining;
    pModuleMethodTable->UNMANAGEDTOMANAGEDTRANSITION    = (FC_UNMANAGEDTOMANAGEDTRANSITION)&GI_UnmanagedToManagedTransition;
    pModuleMethodTable->MANAGEDTOUNMANAGEDTRANSITION    = (FC_MANAGEDTOUNMANAGEDTRANSITION)&GI_ManagedToUnmanagedTransition;

    pModuleMethodTable->EXCEPTIONSEARCHFUNCTIONENTER    = (FC_EXCEPTIONSEARCHFUNCTIONENTER)&GI_ExceptionSearchFunctionEnter;
    pModuleMethodTable->EXCEPTIONSEARCHFILTERENTER      = (FC_EXCEPTIONSEARCHFILTERENTER)&GI_ExceptionSearchFilterEnter;
    pModuleMethodTable->EXCEPTIONSEARCHCATCHERFOUND     = (FC_EXCEPTIONSEARCHCATCHERFOUND)&GI_ExceptionSearchCatcherFound;
    pModuleMethodTable->EXCEPTIONUNWINDFUNCTIONENTER    = (FC_EXCEPTIONUNWINDFUNCTIONENTER)&GI_ExceptionUnwindFunctionEnter;
    pModuleMethodTable->EXCEPTIONUNWINDFINALLYENTER     = (FC_EXCEPTIONUNWINDFINALLYENTER)&GI_ExceptionUnwindFinallyEnter;
    pModuleMethodTable->EXCEPTIONCATCHERENTER           = (FC_EXCEPTIONCATCHERENTER)&GI_ExceptionCatcherEnter;

    pModuleMethodTable->FLAGS |= COR_PRF_ENABLE_FUNCTION_ARGS   |
                                 COR_PRF_ENABLE_FUNCTION_RETVAL |
                                 COR_PRF_ENABLE_FRAME_INFO; // set event mask for slow path

    pModuleMethodTable->FUNCTIONENTER3WITHINFO          = (FC_FUNCTIONENTER3WITHINFO)&GI_FunctionEnter3WithInfo;
    pModuleMethodTable->FUNCTIONTAILCALL3WITHINFO       = (FC_FUNCTIONTAILCALL3WITHINFO)&GI_FunctionTailCall3WithInfo;
    pModuleMethodTable->FUNCTIONLEAVE3WITHINFO          = (FC_FUNCTIONLEAVE3WITHINFO)&GI_FunctionLeave3WithInfo;

    pModuleMethodTable->THREADCREATED                   = (FC_THREADCREATED)&GI_ThreadCreated;
    pModuleMethodTable->THREADDESTROYED                 = (FC_THREADDESTROYED)&GI_ThreadDestroyed;

    // @TODO parameter range testing -- inspection.

    return;
}

